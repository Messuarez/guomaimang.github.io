import{_ as t,f as e}from"./app.471ea2ca.js";const a={},i=e('<h1 id="combinational-logic-4" tabindex="-1"><a class="header-anchor" href="#combinational-logic-4" aria-hidden="true">#</a> Combinational Logic 4</h1><h2 id="finite-state-machine-fsm" tabindex="-1"><a class="header-anchor" href="#finite-state-machine-fsm" aria-hidden="true">#</a> Finite State Machine (FSM)</h2><h3 id="example-3-bit-synchronous-counter" tabindex="-1"><a class="header-anchor" href="#example-3-bit-synchronous-counter" aria-hidden="true">#</a> Example\uFF1A3-bit Synchronous Counter</h3><ul><li>The counter will count through 000, 001, \u2026 , 111, then get back to 000</li><li>Each count (e.g., 001) is a <strong>state</strong> of the counter (machine)</li><li>The number of possible states is <strong>finite</strong></li></ul><p>This 3-bit Synchronous Counter is an example of <strong>Finite State Machine</strong></p><h3 id="concept" tabindex="-1"><a class="header-anchor" href="#concept" aria-hidden="true">#</a> Concept</h3><p><strong>FSM is an abstract model to describe real-world systems</strong></p><ul><li>It uses states to represent the situations that the system is in</li><li>It specifies\u300C\u6307\u5B9A\u300D how the states of the system would change based on the external input, and how the system would produce external output accordingly \u300C\u5B83\u6307\u5B9A\u4E86\u7CFB\u7EDF\u72B6\u6001\u5982\u4F55\u6839\u636E\u5916\u90E8\u8F93\u5165\u8FDB\u884C\u66F4\u6539\uFF0C\u4EE5\u53CA\u7CFB\u7EDF\u5982\u4F55\u76F8\u5E94\u5730\u4EA7\u751F\u5916\u90E8\u8F93\u51FA\u300D <ul><li>The 3-bit Synchronous Counter is a special case \u2013 it does not have external input and output\u300C3\u4F4D\u540C\u6B65\u8BA1\u6570\u5668\u662F\u4E00\u79CD\u7279\u6B8A\u60C5\u51B5\u2013\u5B83\u6CA1\u6709\u5916\u90E8\u8F93\u5165\u548C\u8F93\u51FA\u300D</li><li>However, the 3-bit Synchronous Counter did\u300C\u786E\u5B9E\u300D demonstrate\u300C\u6F14\u793A\u300D an essential\u300C\u91CD\u8981\u300D part of FSM \u2013 the memory component to store the state\u300C\u4F46\u662F\uFF0C3\u4F4D\u540C\u6B65\u8BA1\u6570\u5668\u786E\u5B9E\u6F14\u793A\u4E86FSM\u7684\u91CD\u8981\u90E8\u5206\u2013\u5B58\u50A8\u72B6\u6001\u7684\u5185\u5B58\u7EC4\u4EF6\u300D</li></ul></li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/03/4981a016aed40.png" alt="image.png" title="image.png"><h3 id="formal-model-of-fsm" tabindex="-1"><a class="header-anchor" href="#formal-model-of-fsm" aria-hidden="true">#</a> Formal Model of FSM</h3><p>FSM = (States, Inputs, Outputs, State Transition Function)</p><p>FSM = ( S, I, O, \u03C0)</p><ul><li>S: the finite set of states</li><li>I: the finite set of inputs</li><li>O: the finite set of outputs</li><li>\u03C0: state transition function: define the relations among input, output, current state, next state\u300C\u03C0\uFF1A\u72B6\u6001\u8F6C\u6362\u51FD\u6570\uFF1A\u5B9A\u4E49\u8F93\u5165\uFF0C\u8F93\u51FA\uFF0C\u5F53\u524D\u72B6\u6001\uFF0C\u4E0B\u4E00\u72B6\u6001\u4E4B\u95F4\u7684\u5173\u7CFB\u300D</li></ul><p>Two important relations for FSM</p><ul><li>Next state = external input + current state (i.e., the next state depends on the current state and the external input)</li><li>External output = external input + current state (note: not exactly as this; detailed later)</li></ul><p>There are Two Sub-Models: Mealy Machine vs. Moore Machine</p><h4 id="mealy-machine" tabindex="-1"><a class="header-anchor" href="#mealy-machine" aria-hidden="true">#</a> Mealy Machine</h4><img src="https://pic.hanjiaming.com.cn/2021/04/03/3c102cfca43c9.png" alt="image.png" title="image.png"><p>\u6CE8\uFF1A\u5373\u8F93\u51FA\u7ED3\u5408input\u540E\u518D\u8F93\u51FA</p><h4 id="moore-machine" tabindex="-1"><a class="header-anchor" href="#moore-machine" aria-hidden="true">#</a> Moore Machine</h4><img src="https://pic.hanjiaming.com.cn/2021/04/03/d273b8b4c9ab2.png" alt="image.png" title="image.png"><p>\u6CE8\uFF1A\u5373\u7ED3\u5408input\u524D\u8F93\u51FA</p><ul><li>combinational logic: relates the current state, external input and output, next state</li><li>registers\u2014\u2014memory compoennt: store the state of the machine</li></ul><h3 id="represent" tabindex="-1"><a class="header-anchor" href="#represent" aria-hidden="true">#</a> Represent</h3><p>How to Represent FSM\uFF1FThere are two basic approaches</p><p>Key: represent the relations among current state, input and next state, output &amp; Know how to transform between state diagram and state table</p><ul><li>State diagram</li><li>State table</li></ul><h4 id="state-diagram" tabindex="-1"><a class="header-anchor" href="#state-diagram" aria-hidden="true">#</a> State Diagram</h4><ul><li>Circles: represent states <ul><li>Labelled with\u300C\u4F7F\u7528...\u6807\u8BB0\u300D S_k to denote\u300C\u8868\u793A\u300D the state (or a binary encoding)\u300C\u6807\u8BB0\u4E3AS _ k\u8868\u793A\u72B6\u6001\uFF08\u6216\u4E8C\u8FDB\u5236\u7F16\u7801\uFF09\u300D</li></ul></li><li>Directed arcs\u300C\u6709\u5411\u5F27\u300D: represent the transitions between states <ul><li>Labelled with input/output for that state transition\u300C\u6807\u8BB0\u6709\u8BE5\u72B6\u6001\u8F6C\u6362\u7684\u8F93\u5165/\u8F93\u51FA\u300D</li></ul></li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/03/2c96d1f88b45c.png" alt="image.png" title="image.png"><p>Two circles: initial states</p><p>Example: the current state is S_k, given an external input a, the state will transit to the next state S_j, and the external output is p</p><p>Encoding of states: we ususally use binary numbers to encode the states; for example, if there are four states: S_0 (00), S_1 (01), S_2(10), and S_3(11).</p><p>\u6CE8\uFF1A\u4E0A\u56FE\u8868\u793A\uFF1A\u5728Sk\u72B6\u6001\uFF0C\u5982\u679C\u8F93\u5165a\uFF0C\u5219\u4F1A\u8F93\u51FAp\uFF0C\u72B6\u6001\u53D8\u6210Sj\u3002b/q\u540C\u7406\u3002</p><p>Mealy machine and Moore machine can be labelled differently using State Diagram</p><ul><li>Mealy machine: label directed arcs with input/output for that state transition</li><li>Moore machine: since output depends only on state, we can label directed arcs with input for that state transition, and label state circles with S_k/output</li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/03/c1ece124b719f.png" alt="image.png" title="image.png"><h5 id="restrictions" tabindex="-1"><a class="header-anchor" href="#restrictions" aria-hidden="true">#</a> restrictions</h5><p>Some restrictions on state diagram</p><ul><li>Time is discretized\u300C\u79BB\u6563\u5316\u300D: use clock signal to control the timming of the transitioning of states (synchronous!) -- we usually use time t and t+1 to denote the timing for the current state and next state\u300C\u65F6\u95F4\u79BB\u6563\u5316\uFF1A\u4F7F\u7528\u65F6\u949F\u4FE1\u53F7\u63A7\u5236\u72B6\u6001\u8F6C\u6362\u7684\u65F6\u95F4\uFF08\u540C\u6B65\uFF01\uFF09-\u6211\u4EEC\u901A\u5E38\u4F7F\u7528\u65F6\u95F4t\u548Ct + 1\u8868\u793A\u5F53\u524D\u72B6\u6001\u548C\u4E0B\u4E00\u4E2A\u72B6\u6001\u7684\u65F6\u5E8F\u300D</li><li>FSM can only be in one state at a time -- therefore, only in one state (or one circle) at a time\u300CFSM\u4E00\u6B21\u53EA\u80FD\u5904\u4E8E\u4E00\u79CD\u72B6\u6001-\u56E0\u6B64\uFF0C\u4E00\u6B21\u53EA\u80FD\u5904\u4E8E\u4E00\u79CD\u72B6\u6001\uFF08\u6216\u4E00\u4E2A\u5706\u5708\uFF09\u300D</li></ul><p>State diagram is a clear visualization of FSM; but it is not that convinient for computation \u2013 we use an alternative, which is state table</p><h4 id="state-table" tabindex="-1"><a class="header-anchor" href="#state-table" aria-hidden="true">#</a> State Table</h4><img src="https://pic.hanjiaming.com.cn/2021/04/03/f736420397156.png" alt="image.png" title="image.png"><img src="https://pic.hanjiaming.com.cn/2021/04/03/4a805376f8579.png" alt="image.png" title="image.png"><h5 id="example" tabindex="-1"><a class="header-anchor" href="#example" aria-hidden="true">#</a> Example</h5><img src="https://pic.hanjiaming.com.cn/2021/04/03/926b01dfe54b7.png" alt="image.png" title="image.png"><p>We know these tools to describe it, but what&#39;s the analytical task?</p><h3 id="analytical-task" tabindex="-1"><a class="header-anchor" href="#analytical-task" aria-hidden="true">#</a> Analytical Task</h3><p>The Essential Analytical Task for FSM is</p><ul><li>Given state diagram/state table, derive the functions that specify the relations among next state, output, current state, and input\u300C\u7ED9\u5B9A\u72B6\u6001\u56FE/\u72B6\u6001\u8868\uFF0C\u5BFC\u51FA\u6307\u5B9A\u4E0B\u4E00\u4E2A\u72B6\u6001\uFF0C\u8F93\u51FA\uFF0C\u5F53\u524D\u72B6\u6001\u548C\u8F93\u5165\u4E4B\u95F4\u7684\u5173\u7CFB\u7684\u51FD\u6570\u300D <ul><li>Next state = f (current state, input)</li><li>Output = g (current state, input)</li></ul></li><li>The design of sequential circuits relies on the above two functions</li></ul><h4 id="example-pattern-detector" tabindex="-1"><a class="header-anchor" href="#example-pattern-detector" aria-hidden="true">#</a> Example: Pattern Detector</h4><p>Design a machine that will detect a specific\u300C\u7279\u5B9A\u7684\u300D bit pattern\u300C\u8BBE\u8BA1\u4E00\u53F0\u5C06\u68C0\u6D4B\u7279\u5B9A\u4F4D\u6A21\u5F0F\u7684\u673A\u5668\u300D</p><ul><li>It receives bit stream</li><li>It has one output Z: if the bit pattern appears in the bit stream, the output Z = 1; otherwise, Z = 0\u300C\u5B83\u5177\u6709\u4E00\u4E2A\u8F93\u51FAZ\uFF1A\u5982\u679C\u4F4D\u6A21\u5F0F\u51FA\u73B0\u5728\u4F4D\u6D41\u4E2D\uFF0C\u5219\u8F93\u51FAZ = 1\uFF1B\u5426\u5219\uFF0C\u8F93\u51FAZ = 1\u3002\u5426\u5219\uFF0CZ = 0\u300D</li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/03/f4ed623005136.png" alt="image.png" title="image.png"><h5 id="modelling-the-problem" tabindex="-1"><a class="header-anchor" href="#modelling-the-problem" aria-hidden="true">#</a> Modelling the Problem</h5><p>Modelling the Problem using FSM</p><p>We use the following states to model the possible situations that the machine is in (detect pattern 1101)</p><ul><li>S0: the initial state</li><li>S1: the first desired symbol (1) is detected</li><li>S2: the desired sub-pattern 11 is detected</li><li>S3: the desired sub-pattern 110 is detected</li></ul><p>Intuition: we want to record the situations that will lead to the target pattern 1101</p><h5 id="states-and-states-transitions" tabindex="-1"><a class="header-anchor" href="#states-and-states-transitions" aria-hidden="true">#</a> States and States Transitions</h5><p>States and States Transitions (pattern 1101)</p><img src="https://pic.hanjiaming.com.cn/2021/04/03/113ad305afeb2.png" alt="image.png" title="image.png"><p>Worth to note:</p><p>(1) the transitions from S0 to S1 to S2 to S3 (when desired bit is received)\u300C\uFF081\uFF09\u4ECES0\u5230S1\u5230S2\u5230S3\u7684\u8F6C\u6362\uFF08\u63A5\u6536\u5230\u6240\u9700\u4F4D\u65F6\uFF09\u300D</p><p>(2) For most of the cases when undesired bit is received, it goes back to S0 (restart the detection again)\u300C\uFF082\uFF09\u5728\u5927\u591A\u6570\u60C5\u51B5\u4E0B\uFF0C\u5F53\u6536\u5230\u4E0D\u5E0C\u671B\u7684\u4F4D\u65F6\uFF0C\u5B83\u4F1A\u8FD4\u56DE\u5230S0\uFF08\u518D\u6B21\u91CD\u65B0\u5F00\u59CB\u68C0\u6D4B\uFF09\u300D</p><p>(3) Some special cases: S2 goes back to S2 (11 when received 1); S3 goes to S1 (110 when received 1)\u300C\uFF083\uFF09\u4E00\u4E9B\u7279\u6B8A\u60C5\u51B5\uFF1AS2\u8FD4\u56DE\u5230S2\uFF08\u6536\u52301\u65F6\u4E3A11\uFF09\uFF1B S3\u8F6C\u5230S1\uFF08\u6536\u52301\u65F6\u4E3A110\uFF09\u300D</p><p><strong>This process needs case-by-case careful design</strong></p><h5 id="from-state-diagram-to-functions" tabindex="-1"><a class="header-anchor" href="#from-state-diagram-to-functions" aria-hidden="true">#</a> From State Diagram to Functions</h5><p>Approach: use Truth Table and Karnaugh Map</p><ul><li>Encode the states, input, and output <ul><li>S0 (00), S1(01), S2(10), S3(11)</li></ul></li><li>Construct the state diagram (it is actually a truth table)</li></ul><p>Now you can use K-map</p><img src="https://pic.hanjiaming.com.cn/2021/04/03/6398726ec663b.png" alt="image.png" title="image.png"><p>In the State Diagram (truth table): (1) we use two bits P1\uFF0CP0 to denote the current state; use N1, N0 for the next state (2) (P1,P0,X) are the variables, N1, N0, Z are the function values (3) Given a combination of (P1,P0,X), we need to find the value for N1, N0, Z from the state diagram</p><img src="https://pic.hanjiaming.com.cn/2021/04/03/429f3cb9073ba.png" alt="image.png" title="image.png"><p>The two important relations:</p><ul><li>Next state = current state + input</li><li>Output = current state + input</li></ul><p>We can then contruct the circuits using memory components and combinational logic</p><img src="https://pic.hanjiaming.com.cn/2021/04/03/7de500dd5beba.png" alt="image.png" title="image.png"><h2 id="design-of-sequential-circuits" tabindex="-1"><a class="header-anchor" href="#design-of-sequential-circuits" aria-hidden="true">#</a> Design of sequential circuits</h2><h3 id="a-recap-of-terminologies-on-flip-flops" tabindex="-1"><a class="header-anchor" href="#a-recap-of-terminologies-on-flip-flops" aria-hidden="true">#</a> A Recap of Terminologies on Flip-Flops</h3><p>\u300CFlip-Flops \u672F\u8BED\u7684\u56DE\u987E\u300D</p><ul><li>Symbol (diagram)</li><li>Charactristic table/characteristic equation</li><li>Excitation table</li></ul><img src="https://pic.hanjiaming.com.cn/2021/04/06/30651edb0837b.png" alt="image.png" title="image.png"><h3 id="common-flip-flop-types" tabindex="-1"><a class="header-anchor" href="#common-flip-flop-types" aria-hidden="true">#</a> Common Flip-Flop Types</h3><img src="https://pic.hanjiaming.com.cn/2021/04/08/1ce7bc74c24dd.png" alt="image.png" title="image.png"><h3 id="think" tabindex="-1"><a class="header-anchor" href="#think" aria-hidden="true">#</a> Think</h3><p>For a real-world problem, we know how to get the relations (functions) among input, current state and next state, output\u300C\u5BF9\u4E8E\u4E00\u4E2A\u73B0\u5B9E\u4E16\u754C\u7684\u95EE\u9898\uFF0C\u6211\u4EEC\u77E5\u9053\u5982\u4F55\u83B7\u5F97\u8F93\u5165\uFF0C\u5F53\u524D\u72B6\u6001\u548C\u4E0B\u4E00\u72B6\u6001\uFF0C\u8F93\u51FA\u4E4B\u95F4\u7684\u5173\u7CFB\uFF08\u51FD\u6570\uFF09\u300D</p><p>For implementation using Flip-Flops, we need the input/output of that type of flip-flops\u300C\u5BF9\u4E8E\u4F7F\u7528\u89E6\u53D1\u5668\u7684\u5B9E\u73B0\uFF0C\u6211\u4EEC\u9700\u8981\u8BE5\u7C7B\u578B\u89E6\u53D1\u5668\u7684\u8F93\u5165/\u8F93\u51FA\u300D</p><p>What are the relations between current state/next state and input/output of flip-flops?\u300C\u89E6\u53D1\u5668\u7684\u5F53\u524D\u72B6\u6001/\u4E0B\u4E00\u4E2A\u72B6\u6001\u4E0E\u8F93\u5165/\u8F93\u51FA\u4E4B\u95F4\u6709\u4EC0\u4E48\u5173\u7CFB\uFF1F\u300D</p><p>Back to the Previous Problem</p><p>We are given the state diagram of FSM. We can drive the functions:</p><ul><li>Next state = f (external input, current state)</li><li>External output = g (external input, current state)</li></ul><p>Note: f, g can be relialized using combinational logic</p><p>However, we need to implement f and g using Flip-Flops. What&#39;s the next state? What&#39;s the input to the flip-flops?</p><p><strong>For D Flip-flop, it is easy</strong></p><ul><li>Characteristic equation: Q_{next} = D</li><li>Next state = f (external input, current state)</li><li>D = f (external input, current state)</li></ul><p><strong>Generally, for other flip-flops</strong></p><ul><li>We will use the excitation table of that flip-flop to derive the <strong>excitation table of the circuit</strong></li><li>Excitation table: what <strong>inputs of the flip-flop</strong> are required to transit from one state to the next state\u300C\u4ECE\u4E00\u4E2A\u72B6\u6001\u8F6C\u6362\u5230\u4E0B\u4E00\u4E2A\u72B6\u6001\u9700\u8981\u89E6\u53D1\u5668\u7684\u54EA\u4E9B\u8F93\u5165\u300D</li><li>This excitation table of the circuit is also a truth table: the inputs of the flip-flop are the fucntion values and others are variables</li></ul><h4 id="example-1" tabindex="-1"><a class="header-anchor" href="#example-1" aria-hidden="true">#</a> Example</h4><p>Design a sequential circuit whose state diagram is shown as follows, using J-K Flip-Flops\u300C\u4F7F\u7528J-K\u89E6\u53D1\u5668\u8BBE\u8BA1\u65F6\u5E8F\u7535\u8DEF\uFF0C\u5176\u72B6\u6001\u56FE\u5982\u4E0B\u6240\u793A\u300D</p><p>Encoding:</p><ul><li>Use the outputs of <strong>two</strong> J-K Flip-Flops Q0, Q1 to denote the four states</li><li>Use X to denote the external input</li><li>There is no external output for this FSM</li></ul><p>\u6279\u6CE8\uFF1A\u7528x\u4E3A\u8F93\u5165\uFF0Cx\u4F5C\u4E3A\u4E0B\u4E00\u4E2A\u7684\u8F93\u5165\uFF0C\u968F\u7740\u8F93\u5165\u7684\u53D8\u5316\uFF0C Q0, Q1\u53D1\u751F\u53D8\u5316\u3002\u65E0\u8F93\u51FA\u3002\u5373 x_next = f(x), \u6216\u8005 input = f(x) \u8FD9\u65F6\u6211\u4EEC\u7528\u627E\u51FA\u5F71\u54CDx\u7684\u57FA\u672C\u8981\u7D20\u3002</p><p>\u76EE\u7684\uFF1A\u6784\u5EFA input = f(x) \u51FD\u6570</p><p>1.\u5148\u753B\u51FA \u603B\u90E8\u4EF6 \u7684 Symbol (diagram)</p><img src="https://pic.hanjiaming.com.cn/2021/04/09/f5fe764ca2027.png" alt="image.png" title="image.png" width="300px"><ol start="2"><li>\u753B\u51FA \u5143\u90E8\u4EF6\u7684 Exitation table</li></ol><p>\u5206\u6790\uFF1AQ0, Q1\u7684\u53D8\u5316\u662F\u7531 Q0\u3001Q1\u7684\u5F53\u524D\u72B6\u6001 \u548C J0,K0,J1,K1 \u51B3\u5B9A\u7684</p><ol start="2"><li>\u6839\u636E \u603B\u90E8\u4EF6 \u7684 Symbol (diagram) \u753B\u51FA \u603B\u90E8\u4EF6 \u7684 state table</li></ol><img src="https://pic.hanjiaming.com.cn/2021/04/09/9c56aa52c3e01.png" alt="image.png" title="image.png"><ol start="4"><li>\u6839\u636E \u603B\u90E8\u4EF6 \u7684 state table \u753B\u51FA \u603B\u90E8\u4EF6 \u7684 Excitation table</li></ol><img src="https://pic.hanjiaming.com.cn/2021/04/09/f1853f7c85fe9.png" alt="image.png" title="image.png"><p>For example: the first row, look at Q0, 0 -&gt; 0, the required inputs are J0 = 0, K0 =X</p><p>This is a truth table with Q0 Q1 as variables and J0, K0, J1, K1 as function values (it contains don&#39;t care conditions\u300C\u5B83\u5305\u542B \u65E0\u5173\u6761\u4EF6 \u300D)</p><p>**\u8FD9\u65F6\uFF0C\u6211\u4EEC\u8981\u7528 Q0\uFF0CQ1\uFF0Cx **\u53BB\u8868\u793A next \uFF0C\u5373 next = f(Q0\uFF0CQ1\uFF0Cx )</p><ol start="5"><li>\u5C06 \u5143\u90E8\u4EF6 \u7684 \u8F93\u5165\uFF08J0,K0,J1,K1\uFF09 \u548C \u603B\u90E8\u4EF6\u7684\u8F93\u5165x \u8FDB\u884C\u5BF9\u5E94\uFF0C\u4F7F\u7528\u591A\u79CD\u5316\u7B80\u65B9\u6CD5\uFF0C\u6BD4\u5982k-map</li></ol><p>k-map\u7684\u4E24\u4E2A\u7EF4\u5EA6\u5206\u522B\u662F\u4E24\u7EC4\u53D8\u91CF\u3002</p><img src="https://pic.hanjiaming.com.cn/2021/04/09/43d40e0977472.png" alt="image.png" title="image.png"><ol start="6"><li>\u753B\u51FA\u7535\u8DEF</li></ol><img src="https://pic.hanjiaming.com.cn/2021/04/09/24e7f8ab57dfa.png" alt="image.png" title="image.png" width="300px"><h3 id="summary" tabindex="-1"><a class="header-anchor" href="#summary" aria-hidden="true">#</a> Summary</h3><p>Critical steps of designing sequential circuits</p><p>FSM model (this is the hardest part): define the states and state transitions\u300CFSM\u6A21\u578B\uFF08\u8FD9\u662F\u6700\u96BE\u7684\u90E8\u5206\uFF09\uFF1A\u5B9A\u4E49\u72B6\u6001\u548C\u72B6\u6001\u8F6C\u6362\u300D</p><p>The rest is routine\u300C\u4F8B\u884C\u7684\u300D:</p><ul><li>State table + excitation table of flip-flops -&gt; excitation table of the circuit</li><li>Use K-map to derive the SOP form of two functions: <ul><li>Input of Flip-flips = current state (output of flip-flops) + external input</li><li>External output = current state (output of flip-flops) + external input</li></ul></li></ul><p>\u6279\u6CE8</p><ul><li>\u5BF9\u4E8E Next \uFF0C\u6211\u4EEC\u8981\u627E\u7684\u51FD\u6570\u662F Next = f(\u53D8\u91CF)\uFF1B <ul><li>Next \u80FD\u591F\u88AB \u62C6\u89E3\u6210 \u6709\u5F88\u591A\u4E2A \u57FA\u672C\u5143\u4EF6\u7684Next\uFF0C\u8FD9\u91CC\u9700\u8981\u591A\u4E2A\u51FD\u6570\uFF1A\u6BD4\u5982\u5916\u754C\u8F93\u5165\u7684x\uFF0C\u548C \u5F53\u524D\u72B6\u6001\u503C</li><li>\u4E00\u822C\u9898\u76EE\u4F1A\u7ED9\u51FA \u57FA\u672C\u5143\u4EF6\u3002</li></ul></li><li>\u5BF9\u4E8E Output, \u6211\u4EEC\u8981\u627E\u7684\u51FD\u6570\u662F output = g(\u53D8\u91CF)\uFF1B</li></ul>',127);function n(s,l){return i}var r=t(a,[["render",n]]);export{r as default};
